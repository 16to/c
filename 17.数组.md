# 数组
定义：数组是相同类型元素的集合，使用连续的内存空间存储。

```c
int arr[5]; // 定义一个包含5个整数的数组
```
## 初始化数组
```c
int arr[5] = {1, 2, 3, 4, 5}; // 静态初始化
int arr[] = {1, 2, 3};    // 自动推断大小
```

## 访问数组元素
```c
arr[0] = 10; // 修改第一个元素
printf("%d\n", arr[0]); // 访问第一个元素
```

## 获取数组大小
```c
int size = sizeof(arr) / sizeof(arr[0]); // 计算数组元素个数
```

## 多维数组
```c
int matrix[3][4]; // 定义一个3行4列的二维数组
matrix[0][0] = 1; // 访问二维数组元素
```

## 数组与指针
1. 数组名表示数组的首地址。
2. 可以使用指针遍历数组。
```c
int *p = arr; // 指针指向数组首元素
for (int i = 0; i < size; i++) {
    printf("%d\n", *(p + i)); // 通过指针访问数组元素
}
```

## 静态数组 vs 动态数组
1. 静态数组：在编译时分配内存，大小固定。
2. 动态数组：在运行时分配内存，大小可变。使用`malloc`和`free`进行内存管理。
```c
int *dynamicArr = (int *)malloc(5 * sizeof(int)); // 动态分配内存
free(dynamicArr); // 释放内存
```

## 常见操作
1. 遍历数组
```c
for (int i = 0; i < size; i++) {
    printf("%d\n", arr[i]);
}
```

2. 查找元素
```c
int target = 3;
int found = -1;
for (int i = 0; i < size; i++) {
    if (arr[i] == target) {
        found = i;
        break;
    }
}
if (found != -1) {
    printf("Element found at index: %d\n", found);
} else {
    printf("Element not found\n");
}
```

3. 排序数组
```c
// 简单的冒泡排序示例
int arr[] = {5, 2, 9, 1, 5, 6};
int size = sizeof(arr) / sizeof(arr[0]);
for (int i = 0; i < size - 1; i++) {
    for (int j = 0; j < size - i - 1; j++) {
        if (arr[j] > arr[j + 1]) {
            int temp = arr[j];
            arr[j] = arr[j + 1];
            arr[j + 1] = temp;
        }
    }
}
```

4. 复制数组
```c
int arr[] = {1, 2, 3, 4, 5};
int size = sizeof(arr) / sizeof(arr[0]);
int copyArr[5];
for (int i = 0; i < size; i++) {
    copyArr[i] = arr[i];
}
```

5. 反转数组
```c
// 反转数组示例
int arr[] = {1, 2, 3, 4, 5};
int size = sizeof(arr) / sizeof(arr[0]);
for (int i = 0; i < size / 2; i++) {
    int temp = arr[i];
    arr[i] = arr[size - i - 1];
    arr[size - i - 1] = temp;
}
```

## 注意事项
1. 数组下标从0开始，到`size-1`结束。
2. 访问数组时要确保下标不越界，否则会导致未定义行为。
3. 动态数组使用后要记得释放内存，防止内存泄漏。
4. 多维数组在内存中是按行优先存储的。  
5. 使用`sizeof`操作符时要注意数组和指针的区别，避免误用。
6. 在函数参数中传递数组时，实际上传递的是指向数组首元素的指针，无法获取数组大小。